// eslint-disable-next-line @typescript-eslint/no-use-before-define
var ok = function (value) { return new Ok(value); };
// eslint-disable-next-line @typescript-eslint/no-use-before-define
var err = function (err) { return new Err(err); };
var Ok = /** @class */ (function () {
    function Ok(value) {
        var _this = this;
        this.value = value;
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        this.match = function (ok, _err) {
            return ok(_this.value);
        };
    }
    Ok.prototype.isOk = function () {
        return true;
    };
    Ok.prototype.isErr = function () {
        return !this.isOk();
    };
    Ok.prototype.map = function (f) {
        return ok(f(this.value));
    };
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    Ok.prototype.mapErr = function (_f) {
        return ok(this.value);
    };
    // add info on how this is really useful for converting a
    // Result<Result<T, E2>, E1>
    // into a Result<T, E2>
    Ok.prototype.andThen = function (f) {
        return f(this.value);
    };
    Ok.prototype.asyncAndThen = function (f) {
        return f(this.value);
    };
    Ok.prototype.asyncMap = function (f) {
        return ResultAsync.fromPromise(f(this.value));
    };
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    Ok.prototype.unwrapOr = function (_v) {
        return this.value;
    };
    Ok.prototype._unsafeUnwrap = function () {
        return this.value;
    };
    Ok.prototype._unsafeUnwrapErr = function () {
        throw new Error('Called `_unsafeUnwrapErr` on an Ok');
    };
    return Ok;
}());
var Err = /** @class */ (function () {
    function Err(error) {
        var _this = this;
        this.error = error;
        this.match = function (_ok, err) {
            return err(_this.error);
        };
    }
    Err.prototype.isOk = function () {
        return false;
    };
    Err.prototype.isErr = function () {
        return !this.isOk();
    };
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    Err.prototype.map = function (_f) {
        return err(this.error);
    };
    Err.prototype.mapErr = function (f) {
        return err(f(this.error));
    };
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    Err.prototype.andThen = function (_f) {
        return err(this.error);
    };
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    Err.prototype.asyncAndThen = function (_f) {
        return errAsync(this.error);
    };
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    Err.prototype.asyncMap = function (_f) {
        return errAsync(this.error);
    };
    Err.prototype.unwrapOr = function (v) {
        return v;
    };
    Err.prototype._unsafeUnwrap = function () {
        throw new Error('Called `_unsafeUnwrap` on an Err');
    };
    Err.prototype._unsafeUnwrapErr = function () {
        return this.error;
    };
    return Err;
}());

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

var logWarning = function (warningMessage) {
    if (typeof process !== 'object' ||
        (process.env.NODE_ENV !== 'test' && process.env.NODE_ENV !== 'production')) {
        var yellowColor = '\x1b[33m%s\x1b[0m';
        var warning = ['[neverthrow]', warningMessage].join(' - ');
        console.warn(yellowColor, warning);
    }
};

var ResultAsync = /** @class */ (function () {
    function ResultAsync(res) {
        this._promise = res;
    }
    ResultAsync.fromPromise = function (promise, errorFn) {
        var newPromise = promise.then(function (value) { return new Ok(value); });
        if (errorFn) {
            newPromise = newPromise["catch"](function (e) { return new Err(errorFn(e)); });
        }
        else {
            var warning = [
                '`fromPromise` called without a promise rejection handler',
                'Ensure that you are catching promise rejections yourself, or pass a second argument to `fromPromise` to convert a caught exception into an `Err` instance',
            ].join(' - ');
            logWarning(warning);
        }
        return new ResultAsync(newPromise);
    };
    ResultAsync.prototype.map = function (f) {
        var _this = this;
        return new ResultAsync(this._promise.then(function (res) { return __awaiter(_this, void 0, void 0, function () {
            var _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (res.isErr()) {
                            return [2 /*return*/, new Err(res.error)];
                        }
                        _a = Ok.bind;
                        return [4 /*yield*/, f(res.value)];
                    case 1: return [2 /*return*/, new (_a.apply(Ok, [void 0, _b.sent()]))()];
                }
            });
        }); }));
    };
    ResultAsync.prototype.mapErr = function (f) {
        var _this = this;
        return new ResultAsync(this._promise.then(function (res) { return __awaiter(_this, void 0, void 0, function () {
            var _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (res.isOk()) {
                            return [2 /*return*/, new Ok(res.value)];
                        }
                        _a = Err.bind;
                        return [4 /*yield*/, f(res.error)];
                    case 1: return [2 /*return*/, new (_a.apply(Err, [void 0, _b.sent()]))()];
                }
            });
        }); }));
    };
    ResultAsync.prototype.andThen = function (f) {
        return new ResultAsync(this._promise.then(function (res) {
            if (res.isErr()) {
                return new Err(res.error);
            }
            var newValue = f(res.value);
            return newValue instanceof ResultAsync ? newValue._promise : newValue;
        }));
    };
    ResultAsync.prototype.match = function (ok, _err) {
        return this._promise.then(function (res) { return res.match(ok, _err); });
    };
    ResultAsync.prototype.unwrapOr = function (t) {
        return this._promise.then(function (res) { return res.unwrapOr(t); });
    };
    // Makes ResultAsync awaitable
    ResultAsync.prototype.then = function (successCallback) {
        return this._promise.then(successCallback);
    };
    return ResultAsync;
}());
var okAsync = function (value) {
    return new ResultAsync(Promise.resolve(new Ok(value)));
};
var errAsync = function (err) {
    return new ResultAsync(Promise.resolve(new Err(err)));
};

var toPromise = function (val) {
    return val instanceof Promise ? val : Promise.resolve(val);
};
// Functor implementation for functions
// but tailored specifically for Result
// https://eli.thegreenplace.net/2018/haskell-functions-as-functors-applicatives-and-monads/
var mapFn = function (g, ff) {
    return function (val) {
        return g(ff(val));
    };
};
var chain = function (r1, r2) { return __awaiter(void 0, void 0, void 0, function () {
    var warning, inner, mapped;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                warning = [
                    'DEPRECATION WARNING',
                    'The `chain` API will likely be deprecated in a subsequent version of neverthrow',
                    'Please use the `ResultAsync` API: https://github.com/supermacro/neverthrow/#asynchronous-api',
                ].join(' - ');
                logWarning(warning);
                return [4 /*yield*/, r1];
            case 1:
                inner = _a.sent();
                return [4 /*yield*/, inner.asyncMap(r2)];
            case 2:
                mapped = _a.sent();
                return [2 /*return*/, mapped.andThen(function (inner) { return inner; })];
        }
    });
}); };
var chain3 = function (r1, r2, r3) { return __awaiter(void 0, void 0, void 0, function () {
    var r2Promise, chained, mapped;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                r2Promise = mapFn(toPromise, r2);
                return [4 /*yield*/, chain(r1, r2Promise)];
            case 1:
                chained = _a.sent();
                return [4 /*yield*/, chained.asyncMap(r3)];
            case 2:
                mapped = _a.sent();
                return [2 /*return*/, mapped.andThen(function (inner) { return inner; })];
        }
    });
}); };
var chain4 = function (r1, r2, r3, r4) { return __awaiter(void 0, void 0, void 0, function () {
    var r3Promise, chained, mapped;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                r3Promise = mapFn(toPromise, r3);
                return [4 /*yield*/, chain3(r1, r2, r3Promise)];
            case 1:
                chained = _a.sent();
                return [4 /*yield*/, chained.asyncMap(r4)];
            case 2:
                mapped = _a.sent();
                return [2 /*return*/, mapped.andThen(function (inner) { return inner; })];
        }
    });
}); };
var chain5 = function (r1, r2, r3, r4, r5) { return __awaiter(void 0, void 0, void 0, function () {
    var r4Promise, chained, mapped;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                r4Promise = mapFn(toPromise, r4);
                return [4 /*yield*/, chain4(r1, r2, r3, r4Promise)];
            case 1:
                chained = _a.sent();
                return [4 /*yield*/, chained.asyncMap(r5)];
            case 2:
                mapped = _a.sent();
                return [2 /*return*/, mapped.andThen(function (inner) { return inner; })];
        }
    });
}); };
var chain6 = function (r1, r2, r3, r4, r5, r6) { return __awaiter(void 0, void 0, void 0, function () {
    var r5Promise, chained, mapped;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                r5Promise = mapFn(toPromise, r5);
                return [4 /*yield*/, chain5(r1, r2, r3, r4, r5Promise)];
            case 1:
                chained = _a.sent();
                return [4 /*yield*/, chained.asyncMap(r6)];
            case 2:
                mapped = _a.sent();
                return [2 /*return*/, mapped.andThen(function (inner) { return inner; })];
        }
    });
}); };
var chain7 = function (r1, r2, r3, r4, r5, r6, r7) { return __awaiter(void 0, void 0, void 0, function () {
    var r6Promise, chained, mapped;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                r6Promise = mapFn(toPromise, r6);
                return [4 /*yield*/, chain6(r1, r2, r3, r4, r5, r6Promise)];
            case 1:
                chained = _a.sent();
                return [4 /*yield*/, chained.asyncMap(r7)];
            case 2:
                mapped = _a.sent();
                return [2 /*return*/, mapped.andThen(function (inner) { return inner; })];
        }
    });
}); };
var chain8 = function (r1, r2, r3, r4, r5, r6, r7, r8) { return __awaiter(void 0, void 0, void 0, function () {
    var r7Promise, chained, mapped;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                r7Promise = mapFn(toPromise, r7);
                return [4 /*yield*/, chain7(r1, r2, r3, r4, r5, r6, r7Promise)];
            case 1:
                chained = _a.sent();
                return [4 /*yield*/, chained.asyncMap(r8)];
            case 2:
                mapped = _a.sent();
                return [2 /*return*/, mapped.andThen(function (inner) { return inner; })];
        }
    });
}); };

export { Err, Ok, ResultAsync, chain, chain3, chain4, chain5, chain6, chain7, chain8, err, errAsync, ok, okAsync };
