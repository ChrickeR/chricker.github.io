import commander from 'commander';
import next from 'next';
import { createServer } from 'http';
import SocketIO from 'socket.io';
import chalk from 'chalk';
import open from 'open';
import { ConsoleCapturer } from '@log4brains/cli-common';
import { Log4brains } from '@log4brains/core';
import path from 'path';
import build from 'next/dist/build';
import exportApp from 'next/dist/export';
import loadConfig from 'next/dist/next-server/server/config';
import { PHASE_EXPORT } from 'next/dist/next-server/lib/constants';
import mkdirp from 'mkdirp';
import { makeBadge } from 'badge-maker';
import { promises } from 'fs';
import lunr from 'lunr';

let l4bInstance;
function getL4bInstance() {
  if (!l4bInstance) {
    l4bInstance = Log4brains.createFromCwd(process.env.LOG4BRAINS_CWD || ".");
  }

  return l4bInstance;
}
function getNextJsDir() {
  return path.resolve(path.join(__dirname, "../nextjs")); // only one level up because bundled with microbundle
}
/**
 * #NEXTJS-HACK
 * We want to hide the output of Next.js when we execute CLI commands.
 *
 * @param fn The code which calls Next.js methods for which we want to capture the output
 */

async function execNext(fn) {
  const debug = !!process.env.DEBUG;
  const capturer = new ConsoleCapturer();

  capturer.onLog = (method, args, stream) => {
    if (stream === "stderr" || debug) {
      // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
      capturer.doPrintln(...["[Next] ", ...args].map(a => chalk.dim(a)));
    }
  };

  capturer.start();
  await fn();
  capturer.stop();
}

function isSystemError(obj) {
  return obj instanceof Error && "code" in obj;
}

async function previewCommand({
  appConsole
}, port, openBrowser, adrSlug) {
  process.env.NEXT_TELEMETRY_DISABLED = "1";
  const dev = process.env.NODE_ENV === "development";
  appConsole.startSpinner("Log4brains is starting...");
  appConsole.debug(`Run \`next ${dev ? "dev" : "start"}\`...`);
  const app = next({
    dev,
    dir: getNextJsDir()
  });
  await execNext(async () => {
    await app.prepare();
  });
  /**
   * #NEXTJS-HACK
   * We override this private property to set the incrementalCache in "dev" mode (ie. it disables it)
   * to make our Hot Reload feature work.
   * In fact, we trigger a page re-render every time an ADR changes and we absolutely need up-to-date data on every render.
   * The "serve stale data while revalidating" Next.JS policy is not suitable for us.
   */
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore

  app.server.incrementalCache.incrementalOptions.dev = true; // eslint-disable-line @typescript-eslint/no-unsafe-member-access
  // eslint-disable-next-line @typescript-eslint/no-misused-promises

  const srv = createServer(app.getRequestHandler()); // FileWatcher with Socket.io

  const io = SocketIO(srv);
  const {
    fileWatcher
  } = getL4bInstance();
  fileWatcher.subscribe(event => {
    appConsole.debug(`[FileWatcher] ${event.type} - ${event.relativePath}`);
    io.emit("FileWatcher", event);
  });
  fileWatcher.start();

  try {
    await execNext(() => new Promise((resolve, reject) => {
      // This code catches EADDRINUSE error if the port is already in use
      srv.on("error", reject);
      srv.on("listening", () => resolve());
      srv.listen(port);
    }));
  } catch (err) {
    appConsole.stopSpinner();

    if (isSystemError(err) && err.code === "EADDRINUSE") {
      if (openBrowser && adrSlug) {
        appConsole.println(chalk.dim("Log4brains is already started. We open the browser and exit"));
        await open(`http://localhost:${port}/adr/${adrSlug}`);
        process.exit(0);
      }

      appConsole.fatal(`Port ${port} is already in use. Use the -p <PORT> option to select another one.`);
      process.exit(1);
    } else if (isSystemError(err) && err.code === "EACCES") {
      appConsole.fatal(`Impossible to use port ${port} (permission denied). Use the -p <PORT> option to select another one.`);
      process.exit(1);
    }

    throw err;
  }

  appConsole.stopSpinner();
  appConsole.println(`Your Log4brains preview is ðŸš€ on ${chalk.underline.blueBright(`http://localhost:${port}/`)}`);
  appConsole.println(chalk.dim("Hot Reload is enabled: any change you make to a markdown file is applied live"));

  if (dev) {
    appConsole.println();
    appConsole.println(`${chalk.bgBlue.white.bold(" DEV ")} ${chalk.blue("Next.js' Fast Refresh is enabled")}`);
    appConsole.println();
  }

  if (openBrowser) {
    await open(`http://localhost:${port}/${adrSlug ? `adr/${adrSlug}` : ""}`);
  }
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function mapToJson(map) {
  return Array.from(map.entries());
}

function mapFromJson(entries) {
  return new Map(entries);
}
/**
 * Inspired by https://github.com/squidfunk/mkdocs-material/tree/master/src/assets/javascripts/integrations/search
 */


class Search {
  constructor(index, adrs) {
    this.index = index;
    this.adrs = adrs;
  }

  search(query) {
    return this.index.search(`${query}*`).map(result => {
      const adr = this.adrs.get(result.ref);

      if (!adr) {
        throw new Error(`Invalid Search instance: missing ADR "${result.ref}"`);
      }

      return {
        slug: result.ref,
        href: `/adr/${result.ref}`,
        title: adr.title,
        score: result.score
      };
    });
  }

  serializeIndex() {
    return {
      lunr: this.index.toJSON(),
      adrs: mapToJson(this.adrs)
    };
  }

  static createFromAdrs(adrs) {
    const adrsForSearch = new Map(adrs.map(adr => [adr.slug, {
      title: adr.title || "Untitled",
      verbatim: adr.body.enhancedMdx // TODO: remove tags (https://github.com/thomvaill/log4brains/issues/5)

    }]));
    const index = lunr(builder => {
      builder.ref("slug");
      builder.field("title", {
        boost: 1000
      });
      builder.field("verbatim"); // eslint-disable-next-line no-param-reassign

      builder.metadataWhitelist = ["position"];
      adrsForSearch.forEach((adr, slug) => {
        builder.add({
          slug,
          title: adr.title,
          verbatim: adr.verbatim
        });
      });
    });
    return new Search(index, adrsForSearch);
  }

  static createFromSerializedIndex(serializedIndex) {
    return new Search(lunr.Index.load(serializedIndex.lunr), mapFromJson(serializedIndex.adrs));
  }

}

function toAdrLight(adr) {
  return {
    slug: adr.slug,
    package: adr.package,
    title: adr.title,
    status: adr.status,
    creationDate: adr.creationDate,
    publicationDate: adr.publicationDate
  };
}

async function buildCommand({
  appConsole
}, outPath, basePath) {
  process.env.NEXT_TELEMETRY_DISABLED = "1";
  appConsole.println("Building Log4brains...");
  const nextDir = getNextJsDir(); // eslint-disable-next-line global-require,import/no-dynamic-require,@typescript-eslint/no-var-requires

  const nextConfig = require(path.join(nextDir, "next.config.js")); // We use a different distDir than the preview mode
  // because getStaticPath()'s `fallback` config is somehow cached


  const distDir = ".next-export";

  const nextCustomConfig = _extends({}, nextConfig, {
    distDir,
    basePath,
    env: _extends({}, nextConfig.env && typeof nextConfig.env === "object" ? nextConfig.env : {}, {
      NEXT_PUBLIC_LOG4BRAINS_STATIC: "1"
    })
  });

  appConsole.debug("Run `next build`...");
  await execNext(async () => {
    // #NEXTJS-HACK: build() is not meant to be called from the outside of Next.js
    // And there is an error in their typings: `conf?` is typed as `null`, so we have to use @ts-ignore
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    await build(nextDir, nextCustomConfig);
  });
  appConsole.debug("Run `next export`...");
  await execNext(async () => {
    await exportApp(nextDir, {
      outdir: outPath
    }, await loadConfig(PHASE_EXPORT, nextDir, nextCustomConfig) // Configuration is not handled like in build() here
    );
  });
  appConsole.startSpinner("Generating ADR data...");
  const buildId = await promises.readFile(path.join(nextDir, distDir, "BUILD_ID"), "utf-8"); // TODO: move to a dedicated module

  await mkdirp(path.join(outPath, "data", buildId));
  const adrs = await getL4bInstance().searchAdrs(); // TODO: remove this dead code when we are sure we don't need a JSON file per ADR
  // const packages = new Set<string>();
  // adrs.forEach((adr) => adr.package && packages.add(adr.package));
  // const mkdirpPromises = Array.from(packages).map((pkg) =>
  //   mkdirp(path.join(outPath, `data/adr/${pkg}`))
  // );
  // await Promise.all(mkdirpPromises);

  const promises$1 = [// ...adrs.map((adr) =>
  //   fsP.writeFile(
  //     path.join(outPath, "data", buildId, "adr", `${adr.slug}.json`),
  //     JSON.stringify(
  //       toAdr(
  //         adr,
  //         adr.supersededBy ? getAdrBySlug(adr.supersededBy, adrs) : undefined
  //       )
  //     ),
  //     "utf-8"
  //   )
  // ),
  promises.writeFile(path.join(outPath, "data", buildId, "adrs.json"), JSON.stringify(adrs.map(toAdrLight)), "utf-8")];
  await Promise.all(promises$1); // Badge

  await promises.writeFile(path.join(outPath, "badge.svg"), makeBadge({
    label: "ADRs",
    message: adrs.length.toString(),
    color: "#FF007B"
  }));
  appConsole.updateSpinner("Generating search index...");
  await promises.writeFile(path.join(outPath, "data", buildId, "search-index.json"), JSON.stringify(Search.createFromAdrs(adrs).serializeIndex()), "utf-8");
  appConsole.stopSpinner();
  appConsole.success(`Your Log4brains static site was successfully generated to ${chalk.cyan(outPath)} with a total of ${chalk.cyan(`${adrs.length} ADRs`)}`);
  appConsole.println();
  process.exit(0); // otherwise Next.js's spinner keeps running
}

function createWebCli({
  appConsole
}) {
  const program = new commander.Command();
  program.command("preview [adr]").description("Start Log4brains locally to preview your changes", {
    adr: "If provided, will automatically open your browser to this specific ADR"
  }).option("-p, --port <port>", "Port to listen on", "4004").option("--no-open", "Do not open the browser automatically", false).action((adr, opts) => {
    return previewCommand({
      appConsole
    }, parseInt(opts.port, 10), opts.open, adr);
  });
  program.command("build").description("Build Log4brains as a deployable static website").option("-o, --out <path>", "Output path", ".log4brains/out").option("--basePath <path>", "Custom base path", "").action(opts => {
    return buildCommand({
      appConsole
    }, opts.out, opts.basePath);
  });
  return program;
}

export { createWebCli };
//# sourceMappingURL=index.module.js.map
