{"ast":null,"code":"import { jsxs as _jsxs } from \"react/jsx-runtime\";\nimport { Fragment as _Fragment } from \"react/jsx-runtime\";\nimport _Typography from \"@material-ui/core/Typography\";\nimport _SvgIcon from \"@material-ui/core/SvgIcon\";\nimport _CircularProgress from \"@material-ui/core/CircularProgress\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* eslint-disable @typescript-eslint/ban-types */\nimport React from \"react\";\nimport { Autocomplete } from \"@material-ui/lab\";\nimport { useControlled } from \"@material-ui/core/utils\";\nimport { createStyles, makeStyles } from \"@material-ui/core/styles\";\nimport { GrDocumentText as AdrIcon } from \"react-icons/gr\";\nimport { useRouter } from \"next/router\";\nimport { SearchBar } from \"./components/SearchBar\";\nconst useStyles = makeStyles(theme => {\n  return createStyles({\n    searchBar: {\n      zIndex: \"inherit\"\n    },\n    resultTitle: {\n      marginLeft: \"0.5ch\"\n    },\n    acPaper: {\n      borderRadius: `0 0 ${theme.shape.borderRadius}px ${theme.shape.borderRadius}px`,\n      marginTop: 0\n    }\n  });\n});\nexport function SearchBox(props) {\n  const classes = useStyles();\n\n  const {\n    onOpen,\n    onClose,\n    open: openProp,\n    onQueryChange,\n    query,\n    results,\n    loading = false\n  } = props,\n        otherProps = _objectWithoutProperties(props, [\"onOpen\", \"onClose\", \"open\", \"onQueryChange\", \"query\", \"results\", \"loading\"]);\n\n  const [open, setOpenState] = useControlled({\n    controlled: openProp,\n    default: false,\n    name: \"SearchBox\",\n    state: \"open\"\n  });\n\n  const handleOpen = event => {\n    if (open) {\n      return;\n    }\n\n    setOpenState(true);\n\n    if (onOpen) {\n      onOpen(event);\n    }\n  };\n\n  const router = useRouter();\n\n  const handleClose = (event, reason) => {\n    if (!open) {\n      return;\n    }\n\n    setOpenState(false);\n\n    if (onClose) {\n      onClose(event, reason);\n    }\n  };\n\n  let noOptionsText = \"Type to start searching\";\n\n  if (loading) {\n    noOptionsText = /*#__PURE__*/_jsx(\"div\", {\n      style: {\n        textAlign: \"center\"\n      },\n      children: /*#__PURE__*/_jsx(_CircularProgress, {\n        size: 20\n      })\n    });\n  } else if (query) {\n    noOptionsText = \"No matching documents\";\n  }\n\n  return /*#__PURE__*/_jsx(Autocomplete, _objectSpread(_objectSpread({}, otherProps), {}, {\n    classes: {\n      paper: classes.acPaper\n    },\n    options: results !== null && results !== void 0 ? results : [],\n    getOptionLabel: result => result.title,\n    renderInput: params => /*#__PURE__*/_jsx(SearchBar, _objectSpread(_objectSpread({}, params), {}, {\n      open: open,\n      onClear: event => onQueryChange && onQueryChange(event, \"\", \"clear\"),\n      className: classes.searchBar\n    })),\n    inputValue: query,\n    onInputChange: (event, value, reason) => {\n      // We don't want to replace the inputValue by the selected value\n      if (reason !== \"reset\" && onQueryChange) {\n        onQueryChange(event, value, reason);\n      }\n    },\n    open: open,\n    onOpen: handleOpen,\n    onClose: handleClose,\n    filterOptions: r => r // We hijack Autocomplete's behavior to display search results as options\n    ,\n    renderOption: result => /*#__PURE__*/_jsxs(_Fragment, {\n      children: [/*#__PURE__*/_jsx(_SvgIcon, {\n        fontSize: \"small\",\n        children: /*#__PURE__*/_jsx(AdrIcon, {})\n      }), /*#__PURE__*/_jsx(_Typography, {\n        className: classes.resultTitle,\n        children: result.title\n      })]\n    }),\n    noOptionsText: noOptionsText,\n    onChange: async (_, result) => {\n      if (result) {\n        await router.push(result.href);\n      }\n    }\n  }));\n}","map":null,"metadata":{},"sourceType":"module"}