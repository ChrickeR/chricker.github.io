{"ast":null,"code":"import { jsx as _jsx } from \"react/jsx-runtime\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport React from \"react\";\nimport Router, { useRouter } from \"next/router\"; // import io from \"socket.io-client\"; // loaded by _document.tsx so that we don't add this lib in the static mode bundle\n\nimport { Log4brainsMode, Log4brainsModeContext } from \"../../contexts\";\nimport { AdrBrowserLayout } from \"./AdrBrowserLayout\"; // eslint-disable-next-line import/no-cycle\n\nimport { AdrScene, IndexScene } from \"../../scenes\";\nimport { debug } from \"../../lib/debug\";\n\nfunction isReactElement(component) {\n  return !!component && typeof component === \"object\" && \"type\" in component && \"props\" in component;\n}\n\nfunction isAdrSceneChild(component) {\n  return isReactElement(component) && component.type === AdrScene;\n}\n\nfunction isIndexSceneChild(component) {\n  return isReactElement(component) && component.type === IndexScene;\n}\n\nfunction hasAdrMetadataChanged(previous, current) {\n  return previous.title !== current.title || previous.status !== current.status || previous.package !== current.package || previous.publicationDate !== current.publicationDate;\n}\n\nasync function hotReloadCurrentPage() {\n  /**\n   * #NEXTJS-HACK\n   * We clear Next.JS Router's \"static data cache\" to make our Hot Reload feature work.\n   * In fact, we trigger a page re-render every time an ADR changes and we absolutely need up-to-date data on every render.\n   * So we force a new request to the server.\n   */\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  Router.router.sdc = {};\n  await Router.replace(window.location.href);\n}\n\n// eslint-disable-next-line sonarjs/cognitive-complexity\nexport function ConnectedAdrBrowserLayout(props) {\n  const {\n    adrs: preloadedAdrs\n  } = props;\n  const router = useRouter();\n  const mode = React.useContext(Log4brainsModeContext);\n  const [adrs, setAdrsState] = React.useState(preloadedAdrs ? [...preloadedAdrs].reverse() : preloadedAdrs);\n  const [adrsLoading, setAdrsLoadingState] = React.useState(false);\n  const [routing, setRoutingState] = React.useState(false);\n  const previousProps = React.useRef(null);\n  const latestProps = React.useRef(props);\n  React.useEffect(() => {\n    previousProps.current = latestProps.current;\n    latestProps.current = props;\n  }); // ADRs list for the navigation\n\n  const updateAdrsList = React.useCallback(async () => {\n    setAdrsLoadingState(true);\n    const adrsRes = await (await fetch(mode === Log4brainsMode.preview ? `/api/adr` : `${router.basePath}/data/${process.env.NEXT_BUILD_ID}/adrs.json`)).json();\n    adrsRes.reverse(); // @see Log4brains.searchAdrs(): they are returned by chronological order ASC. We display them DESC in the UI\n\n    setAdrsState(adrsRes);\n    setAdrsLoadingState(false);\n  }, [mode, router.basePath]);\n  React.useEffect(() => {\n    if (!adrs) {\n      void updateAdrsList();\n    }\n  }, [updateAdrsList, adrs]); // Routing progress bar\n\n  Router.events.on(\"routeChangeStart\", () => setRoutingState(true));\n  Router.events.on(\"routeChangeComplete\", () => setRoutingState(false));\n  Router.events.on(\"routeChangeError\", () => setRoutingState(false)); // TODO: show a modal?\n  // Hot Reload\n\n  React.useEffect(() => {\n    if (mode !== Log4brainsMode.preview || window.io === undefined) {\n      return () => {};\n    }\n\n    const socket = io();\n    socket.on(\"FileWatcher\", async event => {\n      debug(`[FileWatcher] ${event.type} - ${event.relativePath}`);\n      const child = React.Children.only(latestProps.current.children);\n      const isMdFile = event.relativePath.toLowerCase().endsWith(\".md\");\n      const isIndexFile = event.relativePath.toLowerCase().endsWith(\"index.md\"); // * HOT RELOAD\n      //    - ADR page && current ADR file changed\n      //    - Index page && index.md changed\n\n      const needsHotReload = isAdrSceneChild(child) && child.props.currentAdr.file.relativePath.toLowerCase() === event.relativePath.toLowerCase() || isIndexSceneChild(child) && isIndexFile;\n\n      if (needsHotReload) {\n        await hotReloadCurrentPage();\n      } // * ADR LIST UPDATE (for menu and nav)\n      //    - If any .md file changed, except:\n      //      - If it's index.md\n      //      - If the current ADR changed (ie a Hot Reload was triggered) BUT not its metadata (title, status, date...) [for perf. reasons]\n\n\n      const previousChild = previousProps.current ? React.Children.only(previousProps.current.children) : undefined;\n      const currentMetadataChanged = isAdrSceneChild(child) && previousChild && isAdrSceneChild(previousChild) && hasAdrMetadataChanged(child.props.currentAdr, previousChild.props.currentAdr);\n\n      if (isMdFile && !isIndexFile && (!needsHotReload || currentMetadataChanged)) {\n        await updateAdrsList();\n      }\n    });\n    return () => {\n      socket.disconnect();\n    };\n  }, [mode, updateAdrsList]);\n  return /*#__PURE__*/_jsx(AdrBrowserLayout, _objectSpread(_objectSpread({}, props), {}, {\n    adrs: adrs,\n    adrsReloading: adrs !== undefined && adrsLoading,\n    routing: routing\n  }));\n}","map":null,"metadata":{},"sourceType":"module"}