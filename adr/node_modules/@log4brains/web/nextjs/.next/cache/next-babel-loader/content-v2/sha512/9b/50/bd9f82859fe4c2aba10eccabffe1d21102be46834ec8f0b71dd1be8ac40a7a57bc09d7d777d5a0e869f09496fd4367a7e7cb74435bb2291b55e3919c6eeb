{"ast":null,"code":"import _defineProperty from \"/Users/thomas/git/log4brains/node_modules/next/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport _regeneratorRuntime from \"/Users/thomas/git/log4brains/node_modules/next/node_modules/@babel/runtime/regenerator\";\nimport _toConsumableArray from \"/Users/thomas/git/log4brains/node_modules/next/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _slicedToArray from \"/Users/thomas/git/log4brains/node_modules/next/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _asyncToGenerator from \"/Users/thomas/git/log4brains/node_modules/next/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport React from \"react\";\nimport Router, { useRouter } from \"next/router\"; // import io from \"socket.io-client\"; // loaded by _document.tsx so that we don't add this lib in the static mode bundle\n\nimport { Log4brainsMode, Log4brainsModeContext } from \"../../contexts\";\nimport { AdrBrowserLayout } from \"./AdrBrowserLayout\"; // eslint-disable-next-line import/no-cycle\n\nimport { AdrScene, IndexScene } from \"../../scenes\";\nimport { debug } from \"../../lib/debug\";\n\nfunction isReactElement(component) {\n  return !!component && typeof component === \"object\" && \"type\" in component && \"props\" in component;\n}\n\nfunction isAdrSceneChild(component) {\n  return isReactElement(component) && component.type === AdrScene;\n}\n\nfunction isIndexSceneChild(component) {\n  return isReactElement(component) && component.type === IndexScene;\n}\n\nfunction hasAdrMetadataChanged(previous, current) {\n  return previous.title !== current.title || previous.status !== current.status || previous[\"package\"] !== current[\"package\"] || previous.publicationDate !== current.publicationDate;\n}\n\nfunction hotReloadCurrentPage() {\n  return _hotReloadCurrentPage.apply(this, arguments);\n}\n\nfunction _hotReloadCurrentPage() {\n  _hotReloadCurrentPage = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            /**\n             * #NEXTJS-HACK\n             * We clear Next.JS Router's \"static data cache\" to make our Hot Reload feature work.\n             * In fact, we trigger a page re-render every time an ADR changes and we absolutely need up-to-date data on every render.\n             * So we force a new request to the server.\n             */\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n            // @ts-ignore\n            Router.router.sdc = {};\n            _context3.next = 3;\n            return Router.replace(window.location.href);\n\n          case 3:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n  return _hotReloadCurrentPage.apply(this, arguments);\n}\n\n// eslint-disable-next-line sonarjs/cognitive-complexity\nexport function ConnectedAdrBrowserLayout(props) {\n  var preloadedAdrs = props.adrs;\n  var router = useRouter();\n  var mode = React.useContext(Log4brainsModeContext);\n\n  var _React$useState = React.useState(preloadedAdrs ? _toConsumableArray(preloadedAdrs).reverse() : preloadedAdrs),\n      _React$useState2 = _slicedToArray(_React$useState, 2),\n      adrs = _React$useState2[0],\n      setAdrsState = _React$useState2[1];\n\n  var _React$useState3 = React.useState(false),\n      _React$useState4 = _slicedToArray(_React$useState3, 2),\n      adrsLoading = _React$useState4[0],\n      setAdrsLoadingState = _React$useState4[1];\n\n  var _React$useState5 = React.useState(false),\n      _React$useState6 = _slicedToArray(_React$useState5, 2),\n      routing = _React$useState6[0],\n      setRoutingState = _React$useState6[1];\n\n  var previousProps = React.useRef(null);\n  var latestProps = React.useRef(props);\n  React.useEffect(function () {\n    previousProps.current = latestProps.current;\n    latestProps.current = props;\n  }); // ADRs list for the navigation\n\n  var updateAdrsList = React.useCallback( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n    var adrsRes;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            setAdrsLoadingState(true);\n            _context.next = 3;\n            return fetch(mode === Log4brainsMode.preview ? \"/api/adr\" : \"\".concat(router.basePath, \"/data/\").concat(process.env.NEXT_BUILD_ID, \"/adrs.json\"));\n\n          case 3:\n            _context.next = 5;\n            return _context.sent.json();\n\n          case 5:\n            adrsRes = _context.sent;\n            adrsRes.reverse(); // @see Log4brains.searchAdrs(): they are returned by chronological order ASC. We display them DESC in the UI\n\n            setAdrsState(adrsRes);\n            setAdrsLoadingState(false);\n\n          case 9:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  })), [mode, router.basePath]);\n  React.useEffect(function () {\n    if (!adrs) {\n      void updateAdrsList();\n    }\n  }, [updateAdrsList, adrs]); // Routing progress bar\n\n  Router.events.on(\"routeChangeStart\", function () {\n    return setRoutingState(true);\n  });\n  Router.events.on(\"routeChangeComplete\", function () {\n    return setRoutingState(false);\n  });\n  Router.events.on(\"routeChangeError\", function () {\n    return setRoutingState(false);\n  }); // TODO: show a modal?\n  // Hot Reload\n\n  React.useEffect(function () {\n    if (mode !== Log4brainsMode.preview || window.io === undefined) {\n      return function () {};\n    }\n\n    var socket = io();\n    socket.on(\"FileWatcher\", /*#__PURE__*/function () {\n      var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(event) {\n        var child, isMdFile, isIndexFile, needsHotReload, previousChild, currentMetadataChanged;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                debug(\"[FileWatcher] \".concat(event.type, \" - \").concat(event.relativePath));\n                child = React.Children.only(latestProps.current.children);\n                isMdFile = event.relativePath.toLowerCase().endsWith(\".md\");\n                isIndexFile = event.relativePath.toLowerCase().endsWith(\"index.md\"); // * HOT RELOAD\n                //    - ADR page && current ADR file changed\n                //    - Index page && index.md changed\n\n                needsHotReload = isAdrSceneChild(child) && child.props.currentAdr.file.relativePath.toLowerCase() === event.relativePath.toLowerCase() || isIndexSceneChild(child) && isIndexFile;\n\n                if (!needsHotReload) {\n                  _context2.next = 8;\n                  break;\n                }\n\n                _context2.next = 8;\n                return hotReloadCurrentPage();\n\n              case 8:\n                // * ADR LIST UPDATE (for menu and nav)\n                //    - If any .md file changed, except:\n                //      - If it's index.md\n                //      - If the current ADR changed (ie a Hot Reload was triggered) BUT not its metadata (title, status, date...) [for perf. reasons]\n                previousChild = previousProps.current ? React.Children.only(previousProps.current.children) : undefined;\n                currentMetadataChanged = isAdrSceneChild(child) && previousChild && isAdrSceneChild(previousChild) && hasAdrMetadataChanged(child.props.currentAdr, previousChild.props.currentAdr);\n\n                if (!(isMdFile && !isIndexFile && (!needsHotReload || currentMetadataChanged))) {\n                  _context2.next = 13;\n                  break;\n                }\n\n                _context2.next = 13;\n                return updateAdrsList();\n\n              case 13:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }));\n\n      return function (_x) {\n        return _ref2.apply(this, arguments);\n      };\n    }());\n    return function () {\n      socket.disconnect();\n    };\n  }, [mode, updateAdrsList]);\n  return /*#__PURE__*/_jsx(AdrBrowserLayout, _objectSpread(_objectSpread({}, props), {}, {\n    adrs: adrs,\n    adrsReloading: adrs !== undefined && adrsLoading,\n    routing: routing\n  }));\n}","map":null,"metadata":{},"sourceType":"module"}